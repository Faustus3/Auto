<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Director's Script Engine</title>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier Prime', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Linke Spalte - The Bible */
        .bible-panel {
            width: 25%;
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            transition: all 0.3s ease;
        }

        .bible-panel::-webkit-scrollbar {
            width: 8px;
        }

        .bible-panel::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .bible-panel::-webkit-scrollbar-thumb {
            background: #8b9dc3;
            border-radius: 4px;
        }

        .bible-panel::-webkit-scrollbar-thumb:hover {
            background: #c73e1d;
        }

        .bible-panel.collapsed {
            width: 60px;
            padding: 10px;
            overflow: hidden;
        }

        .bible-panel.collapsed h2,
        .bible-panel.collapsed .bible-section,
        .bible-panel.collapsed .add-character-btn {
            display: none;
        }

        .bible-panel h2 {
            color: #8b9dc3;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toggle-btn {
            background: none;
            border: 1px solid #8b9dc3;
            color: #8b9dc3;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            font-family: 'Courier Prime', monospace;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .toggle-btn:hover {
            background: #8b9dc3;
            color: #1a1a1a;
        }

        .bible-section {
            margin-bottom: 25px;
        }

        .bible-section h3 {
            color: #a0a0a0;
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .bible-textarea {
            width: 100%;
            min-height: 120px;
            background: #0f0f0f;
            border: 1px solid #333;
            color: #c0c0c0;
            padding: 10px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .bible-textarea:focus {
            outline: none;
            border-color: #8b9dc3;
        }

        /* Character Cards */
        .character-cards {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 5px;
        }

        .character-cards::-webkit-scrollbar {
            width: 6px;
        }

        .character-cards::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .character-cards::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .character-card {
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .character-card.editing {
            border-color: #8b9dc3;
            background: #1a2a3a;
        }

        .character-card:hover {
            border-color: #8b9dc3;
            transform: translateY(-1px);
        }

        .character-card.expanded {
            background: #1a1a1a;
            border-color: #8b9dc3;
        }

        .character-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .character-name {
            font-size: 14px;
            font-weight: bold;
            color: #8b9dc3;
        }

        .character-role {
            font-size: 11px;
            color: #a0a0a0;
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 2px;
            text-transform: uppercase;
        }

        .character-summary {
            font-size: 12px;
            color: #c0c0c0;
            line-height: 1.4;
        }

        .character-details {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #333;
        }

        .character-card.expanded .character-details {
            display: block;
        }

        .character-detail-item {
            margin-bottom: 8px;
        }

        .character-detail-label {
            font-size: 11px;
            color: #a0a0a0;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .character-detail-value {
            font-size: 12px;
            color: #e0e0e0;
            line-height: 1.4;
        }

        .character-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: none;
            gap: 5px;
        }

        .character-card:hover .character-actions {
            display: flex;
        }

        .character-action-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px;
            font-size: 10px;
            transition: color 0.2s;
        }

        .character-action-btn:hover {
            color: #c73e1d;
        }

        .character-edit-btn:hover {
            color: #8b9dc3;
        }

        .add-character-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            margin-bottom: 15px;
        }

        .add-character-btn:hover {
            background: #8b9dc3;
            border-color: #8b9dc3;
        }

        /* Mittlere Spalte - The Script */
        .script-panel {
            width: 50%;
            background: #0f0f0f;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .script-panel.expanded {
            width: 80%;
        }

        .script-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            background: #1a1a1a;
        }

        .script-header h2 {
            color: #c73e1d;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .script-editor {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .script-editor::-webkit-scrollbar {
            width: 10px;
        }

        .script-editor::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        .script-editor::-webkit-scrollbar-thumb {
            background: #c73e1d;
            border-radius: 5px;
        }

        .script-editor::-webkit-scrollbar-thumb:hover {
            background: #d84e2d;
        }

        .script-textarea {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-family: 'Courier Prime', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
        }

        .script-textarea:focus {
            outline: none;
        }

        /* Rechte Spalte - The Dramaturg */
        .dramaturg-panel {
            width: 25%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        .dramaturg-panel::-webkit-scrollbar {
            width: 8px;
        }

        .dramaturg-panel::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .dramaturg-panel::-webkit-scrollbar-thumb {
            background: #8b9dc3;
            border-radius: 4px;
        }

        .dramaturg-panel::-webkit-scrollbar-thumb:hover {
            background: #c73e1d;
        }

        .dramaturg-panel.expanded {
            width: 40%;
        }

        .dramaturg-header {
            padding: 20px;
            border-bottom: 1px solid #333;
        }

        .dramaturg-header h2 {
            color: #8b9dc3;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-expand-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            font-family: 'Courier Prime', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 10px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .chat-expand-btn:hover {
            background: #c73e1d;
            border-color: #c73e1d;
        }

        .chat-clear-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            font-family: 'Courier Prime', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 5px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .chat-clear-btn:hover {
            background: #ff4444;
            border-color: #ff4444;
        }

        .ollama-config {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .ollama-url-input {
            flex: 1;
            background: #0f0f0f;
            border: 1px solid #333;
            color: #e0e0e0;
            padding: 5px 8px;
            font-family: 'Courier Prime', monospace;
            font-size: 11px;
        }

        .ollama-url-input:focus {
            outline: none;
            border-color: #8b9dc3;
        }

        .ollama-save-btn {
            background: #4a9d4a;
            border: none;
            color: white;
            padding: 5px 10px;
            font-family: 'Courier Prime', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

.ollama-save-btn:hover {
            background: #5aad5a;
        }

        /* Agentic AI Status Panel Styles */
        .agent-status-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
        }

        .agent-status-panel h4 {
            color: #8b9dc3;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .agent-status-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }

        .status-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            color: #e0e0e0;
            font-weight: bold;
        }

        .status-value.processing {
            color: #f39c12;
        }

        .status-value.ready {
            color: #27ae60;
        }

        .status-value.error {
            color: #e74c3c;
        }

        .agent-controls {
            display: flex;
            gap: 8px;
        }

        .agent-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 8px 12px;
            font-family: 'Courier Prime', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 3px;
            flex: 1;
        }

        .agent-btn:hover {
            background: #8b9dc3;
            border-color: #8b9dc3;
            color: #1a1a1a;
        }

        .smart-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 0 20px 20px;
        }

        .action-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 12px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .action-btn:hover {
            background: #c73e1d;
            border-color: #c73e1d;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 4px;
            min-height: 200px;
            max-height: 70vh;
            transition: max-height 0.3s ease;
        }

        .chat-messages.expanded {
            max-height: 85vh;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #8b9dc3;
            border-radius: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #c73e1d;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.5;
        }

        .user-message {
            background: #2a2a2a;
            border-left: 3px solid #8b9dc3;
        }

        .ai-message {
            background: #1a3a2a;
            border-left: 3px solid #4a9d4a;
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            background: #0f0f0f;
            border: 1px solid #333;
            color: #e0e0e0;
            padding: 10px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #8b9dc3;
        }

        .send-btn {
            background: #c73e1d;
            border: none;
            color: white;
            padding: 10px 20px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .send-btn:hover {
            background: #d84e2d;
        }

        .export-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px;
            margin: 20px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .export-btn:hover {
            background: #8b9dc3;
            border-color: #8b9dc3;
        }

        /* Upload Button */
        .upload-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px;
            margin: 0 20px 20px;
            font-family: 'Courier Prime', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: calc(100% - 40px);
        }

        .upload-btn:hover {
            background: #4a6a4a;
            border-color: #4a6a4a;
        }

        /* File Input (versteckt) */
        .file-input {
            display: none;
        }

        /* Upload Status */
        .upload-status {
            padding: 10px;
            margin: 0 20px 20px;
            background: #1a3a2a;
            border: 1px solid #4a9d4a;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            display: none;
        }

        .upload-status.success {
            background: #1a3a2a;
            border-color: #4a9d4a;
            color: #e0e0e0;
        }

        .upload-status.error {
            background: #3a1a1a;
            border-color: #c73e1d;
            color: #e0e0e0;
        }

        /* Upload Progress */
        .upload-progress {
            padding: 10px;
            margin: 0 20px 20px;
            background: #1a2a3a;
            border: 1px solid #8b9dc3;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #0f0f0f;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #8b9dc3;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Linke Spalte - The Bible -->
        <div class="bible-panel">
            <h2>The Bible<button class="toggle-btn" id="toggleBibleBtn">-</button></h2>
            
            <div class="bible-section">
                <h3>Charaktere</h3>
                <button class="add-character-btn" id="addCharacterBtn">Neuer Charakter</button>
                <div class="character-cards" id="characterCards"></div>
            </div>
            
            <div class="bible-section">
                <h3>Drehorte</h3>
                <textarea class="bible-textarea" id="locations" placeholder="ORT&#10;Beschreibung:&#10;Atmosph√§re:&#10;Bedeutung:"></textarea>
            </div>
            
            <div class="bible-section">
                <h3>Hintergr√ºnde</h3>
                <textarea class="bible-textarea" id="background" placeholder="WELT/ZEIT&#10;Regeln:&#10;Konflikte:&#10;Themen:"></textarea>
            </div>
        </div>
        
        <!-- Mittlere Spalte - The Script -->
        <div class="script-panel">
            <div class="script-header">
                <h2>The Script</h2>
            </div>
            <div class="script-editor">
                <textarea class="script-textarea" id="script" placeholder="FADE IN:

EXT. ORT - TAG

Eine Beschreibung der Szene.

                        CHARAKTER
            Dialogtext hier.

                        ANDERER CHARAKTER
            Antwort hier.

FADE OUT."></textarea>
            </div>
        </div>
        
        <!-- Rechte Spalte - The Dramaturg -->
        <div class="dramaturg-panel">
            <div class="dramaturg-header">
                <h2>Directorial Notes<button class="toggle-btn" id="toggleDramaturgBtn">-</button></h2>
<div class="ollama-config">
                    <input type="text" class="ollama-url-input" id="ollamaUrlInput" placeholder="Ollama URL">
                    <button class="ollama-save-btn" id="saveOllamaUrl">Speichern</button>
                </div>
                
                <!-- Agentic AI Status Panel -->
                <div class="agent-status-panel" id="agentStatusPanel">
                    <h4>ü§ñ Agentic AI Status</h4>
                    <div class="agent-status-info">
                        <div class="status-item">
                            <span class="status-label">Status:</span>
                            <span class="status-value" id="agentStatus">Initializing...</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Current Task:</span>
                            <span class="status-value" id="agentCurrentTask">None</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Queue:</span>
                            <span class="status-value" id="agentQueue">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Memory:</span>
                            <span class="status-value" id="agentMemory">0</span>
                        </div>
                    </div>
                    <div class="agent-controls">
                        <button class="agent-btn" id="agentProactiveBtn">Proactive Analysis</button>
                        <button class="agent-btn" id="agentClearMemoryBtn">Clear Memory</button>
                    </div>
                </div>
                
                <div style="margin-top: 10px;">
                    <button class="chat-expand-btn" id="expandChatBtn">Chat vergr√∂√üern</button>
                    <button class="chat-clear-btn" id="clearChatBtn">Chat l√∂schen</button>
                </div>
            </div>
            
        <div class="smart-actions">
            <button class="action-btn" id="analyzeScene">Szene analysieren</button>
            <button class="action-btn" id="dialogCheck">Dialog-Check</button>
            <button class="action-btn" id="continueWriting">Weiterschreiben</button>
            <button class="action-btn" id="writeScript">Skript schreiben</button>
            <button class="action-btn" id="progressiveWriting">Progressives Schreiben</button>
            <button class="action-btn" id="editScript">Skript bearbeiten</button>
            <button class="action-btn" id="editBackground">Background bearbeiten</button>
            <button class="action-btn" id="readBackground">Background lesen</button>
        </div>
            
            <div class="chat-container">
                <div class="chat-messages" id="chatMessages">
                    <div class="message ai-message">
                        Willkommen bei der Director's Script Engine. Ich bin Ihr Script-Consultant und helfe Ihnen bei der Entwicklung Ihres Drehbuchs. Stellen Sie mir Fragen oder nutzen Sie die Smart Actions f√ºr gezielte Analysen.
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Frage an den Dramaturgen...">
                    <button class="send-btn" id="sendMessageBtn">Senden</button>
                </div>
            </div>
            
            <button class="export-btn" id="exportBtn">Arbeit exportieren</button>
            
            <!-- Upload Section -->
            <input type="file" class="file-input" id="fileInput" accept=".json,.txt,.doc,.docx">
            <button class="upload-btn" id="uploadBtn">Knowledge Base importieren (.json, .txt, .doc, .docx)</button>
            <div class="upload-progress" id="uploadProgress">
                <div>Konvertierung l√§uft...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            <div class="upload-status" id="uploadStatus"></div>
        </div>
    </div>

    <script>
        // IndexedDB f√ºr Datenpersistenz
        const DB_NAME = 'DirectorsScriptEngine';
        const DB_VERSION = 1;
        let db;
        let characters = []; // Array f√ºr Charakter-Kacheln

        // IndexedDB initialisieren
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('scriptData')) {
                        db.createObjectStore('scriptData');
                    }
                };
            });
        }

        // Daten speichern
        async function saveData(key, data) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['scriptData'], 'readwrite');
                const store = transaction.objectStore('scriptData');
                const request = store.put(data, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Daten laden
        async function loadData(key) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['scriptData'], 'readonly');
                const store = transaction.objectStore('scriptData');
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Alle Daten laden
        async function loadAllData() {
            const locations = await loadData('locations') || '';
            const background = await loadData('background') || '';
            const script = await loadData('script') || '';

            // Sicherheitspr√ºfungen f√ºr DOM-Elemente
            const locationsElement = document.getElementById('locations');
            const backgroundElement = document.getElementById('background');
            const scriptElement = document.getElementById('script');

            if (locationsElement) locationsElement.value = locations;
            if (backgroundElement) backgroundElement.value = background;
            if (scriptElement) scriptElement.value = script;

            // Charakter-Kacheln laden (ersetzt das alte characters textarea)
            await loadCharacters();
        }

        // Charakter-Kacheln laden
        async function loadCharacters() {
            const savedCharacters = await loadData('characterCards') || [];
            characters = Array.isArray(savedCharacters) ? savedCharacters : [];
            renderAllCharacters();
        }

        // Charakter-Kacheln speichern
        async function saveCharacters() {
            await saveData('characterCards', characters);
        }

        // Charakter-Kachel erstellen
        function createCharacterCard(character, index) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.index = index;

            card.innerHTML = `
                <div class="character-card-header">
                    <div class="character-name">${character.name}</div>
                    <div class="character-role">${character.role || 'Charakter'}</div>
                </div>
                <div class="character-summary">${character.summary || 'Keine Zusammenfassung verf√ºgbar.'}</div>
                <div class="character-details">
                    <div class="character-detail-item">
                        <div class="character-detail-label">Alter</div>
                        <div class="character-detail-value">${character.age || 'Unbekannt'}</div>
                    </div>
                    <div class="character-detail-item">
                        <div class="character-detail-label">Aussehen</div>
                        <div class="character-detail-value">${character.appearance || 'Nicht beschrieben'}</div>
                    </div>
                    <div class="character-detail-item">
                        <div class="character-detail-label">Pers√∂nlichkeit</div>
                        <div class="character-detail-value">${character.personality || 'Nicht beschrieben'}</div>
                    </div>
                    <div class="character-detail-item">
                        <div class="character-detail-label">Motivation</div>
                        <div class="character-detail-value">${character.motivation || 'Nicht beschrieben'}</div>
                    </div>
                    <div class="character-detail-item">
                        <div class="character-detail-label">Hintergrund</div>
                        <div class="character-detail-value">${character.background || 'Nicht beschrieben'}</div>
                    </div>
                </div>
                <div class="character-actions">
                    <button class="character-action-btn" onclick="deleteCharacter(${index})">√ó</button>
                </div>
            `;

            card.addEventListener('click', (e) => {
                if (!e.target.classList.contains('character-action-btn')) {
                    toggleCharacterCard(card);
                }
            });

            return card;
        }

        // Alle Charakter-Kacheln rendern
        function renderAllCharacters() {
            const container = document.getElementById('characterCards');
            container.innerHTML = '';

            characters.forEach((character, index) => {
                const card = createCharacterCard(character, index);
                container.appendChild(card);
            });
        }

        // Charakter-Kachel expandieren/collapsen
        function toggleCharacterCard(card) {
            card.classList.toggle('expanded');
        }

        // Neuen Charakter hinzuf√ºgen
        function addCharacter(characterData = null) {
            const newCharacter = characterData || {
                name: 'Neuer Charakter',
                role: 'Charakter',
                age: '',
                appearance: '',
                personality: '',
                motivation: '',
                background: '',
                summary: 'Neuer Charakter ohne Beschreibung.'
            };

            characters.push(newCharacter);
            saveCharacters();
            renderAllCharacters();
        }

        // Charakter l√∂schen
        window.deleteCharacter = function(index) {
            if (confirm('Charakter wirklich l√∂schen?')) {
                characters.splice(index, 1);
                saveCharacters();
                renderAllCharacters();
            }
        };

        // Ollama-Antwort f√ºr Charakter parsen - Robuster Parser
        function parseCharacterFromResponse(response, requestedName = '') {
            console.log('Parsing response:', response);

            const character = {
                name: requestedName || 'Unbenannter Charakter',
                role: 'Charakter',
                age: '',
                appearance: '',
                personality: '',
                motivation: '',
                background: '',
                summary: ''
            };

            // Versuche verschiedene Parsing-Strategien

            // Strategie 1: Nach Schl√ºsselw√∂rtern suchen (case-insensitive)
            const lines = response.split('\n').map(line => line.trim()).filter(line => line);

            lines.forEach(line => {
                const lowerLine = line.toLowerCase();

                // Name finden
                if (lowerLine.includes('name:') || (lowerLine.includes('name') && !lowerLine.includes('filename'))) {
                    const match = line.match(/name:?\s*(.+)/i);
                    if (match) character.name = match[1].trim();
                }

                // Alter finden
                if (lowerLine.includes('alter:') || lowerLine.includes('age:')) {
                    const match = line.match(/(alter|age):?\s*(.+)/i);
                    if (match) character.age = match[2].trim();
                }

                // Aussehen finden
                if (lowerLine.includes('aussehen:') || lowerLine.includes('appearance:')) {
                    const match = line.match(/(aussehen|appearance):?\s*(.+)/i);
                    if (match) character.appearance = match[2].trim();
                }

                // Pers√∂nlichkeit finden
                if (lowerLine.includes('pers√∂nlichkeit:') || lowerLine.includes('personality:')) {
                    const match = line.match(/(pers√∂nlichkeit|personality):?\s*(.+)/i);
                    if (match) character.personality = match[2].trim();
                }

                // Motivation finden
                if (lowerLine.includes('motivation:')) {
                    const match = line.match(/motivation:?\s*(.+)/i);
                    if (match) character.motivation = match[2].trim();
                }

                // Hintergrund finden
                if (lowerLine.includes('hintergrund:') || lowerLine.includes('background:')) {
                    const match = line.match(/(hintergrund|background):?\s*(.+)/i);
                    if (match) character.background = match[2].trim();
                }

                // Rolle finden
                if (lowerLine.includes('rolle:') || lowerLine.includes('role:')) {
                    const match = line.match(/(rolle|role):?\s*(.+)/i);
                    if (match) character.role = match[2].trim();
                }
            });

            // Strategie 2: Fallback - wenn keine strukturierten Daten gefunden wurden,
            // verwende die gesamte Antwort als Hintergrund
            if (!character.appearance && !character.personality && !character.motivation && !character.background) {
                // Extrahiere sinnvolle Informationen aus der freien Antwort
                const sentences = response.split(/[.!?]+/).filter(s => s.trim().length > 10);
                if (sentences.length > 0) {
                    character.background = sentences.slice(0, 2).join('. ').trim();
                    character.personality = sentences.length > 2 ? sentences[2] : 'Nicht spezifiziert';
                }
            }

            // Zusammenfassung erstellen
            const ageInfo = character.age ? `${character.age} Jahre alt` : 'Alter unbekannt';
            const personalityInfo = character.personality ? character.personality : 'Pers√∂nlichkeit nicht beschrieben';
            character.summary = `${character.name} ist ${ageInfo}. ${personalityInfo}`;

            console.log('Parsed character:', character);
            return character;
        }

// Enhanced Auto-Save with Proactive Analysis
function setupAutoSave() {
            const elements = ['locations', 'background', 'script'];
            let proactiveTimeout = null;

            elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', () => {
                        saveData(id, element.value);
                        
                        // Trigger proactive analysis for script changes
                        if (id === 'script' && aiAgent) {
                            // Clear existing timeout
                            if (proactiveTimeout) {
                                clearTimeout(proactiveTimeout);
                            }
                            
                            // Set new timeout for proactive analysis (debounced)
                            proactiveTimeout = setTimeout(async () => {
                                const scriptContent = element.value;
                                if (scriptContent.length > 200) { // Only analyze if there's substantial content
                                    try {
                                        const task = 'Quick proactive analysis: Check for any obvious issues, continuity problems, or opportunities for improvement in this script excerpt.';
                                        const context = {
                                            script: scriptContent.substring(0, 1000),
                                            type: 'proactive_quick',
                                            timestamp: Date.now()
                                        };
                                        
                                        const result = await aiAgent.executeTask(task, context);
                                        
                                        // Show as a subtle suggestion, not a full message
                                        if (result && result.length > 50) {
                                            const suggestion = result.substring(0, 200) + '...';
                                            console.log('ü§ñ Proactive suggestion:', suggestion);
                                            
                                            // Optionally show in UI as a non-intrusive tooltip
                                            showProactiveSuggestion(suggestion);
                                        }
                                    } catch (error) {
                                        console.log('Proactive analysis failed:', error);
                                    }
                                }
                            }, 5000); // Wait 5 seconds after user stops typing
                        }
                    });
                }
            });
        }

        // Show proactive suggestions in a non-intrusive way
        function showProactiveSuggestion(suggestion) {
            // Create or update suggestion element
            let suggestionElement = document.getElementById('proactiveSuggestion');
            if (!suggestionElement) {
                suggestionElement = document.createElement('div');
                suggestionElement.id = 'proactiveSuggestion';
                suggestionElement.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #1a1a1a;
                    border: 1px solid #8b9dc3;
                    border-radius: 5px;
                    padding: 10px;
                    color: #e0e0e0;
                    font-size: 12px;
                    max-width: 300px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(suggestionElement);
            }
            
            suggestionElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 5px;">
                    <span style="color: #8b9dc3; font-weight: bold;">ü§ñ Proactive Suggestion</span>
                    <button onclick="this.parentElement.parentElement.style.opacity='0'" style="background: none; border: none; color: #888; cursor: pointer;">√ó</button>
                </div>
                <div>${suggestion}</div>
            `;
            
            // Show with fade-in
            setTimeout(() => {
                suggestionElement.style.opacity = '0.9';
            }, 100);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (suggestionElement) {
                    suggestionElement.style.opacity = '0';
                }
            }, 10000);
        }

// ========================================
        // AGENTIC AI SYSTEM - COMPLETE REDESIGN
        // ========================================

        // Core Agentic Memory System
        class AgentMemory {
            constructor() {
                this.shortTermMemory = [];
                this.longTermMemory = {};
                this.scriptMemory = {};
                this.learningMemory = {};
                this.contextCache = new Map();
                this.maxShortTermSize = 50;
            }

            async initialize() {
                // Load existing memory from storage
                const stored = localStorage.getItem('agentMemory');
                if (stored) {
                    const data = JSON.parse(stored);
                    Object.assign(this, data);
                }
            }

            async store(type, content, metadata = {}) {
                const entry = {
                    type,
                    content,
                    metadata,
                    timestamp: Date.now(),
                    id: this._generateId()
                };

                if (type === 'interaction' || type === 'recent') {
                    this.shortTermMemory.push(entry);
                    if (this.shortTermMemory.length > this.maxShortTermSize) {
                        this.shortTermMemory.shift();
                    }
                } else {
                    if (!this.longTermMemory[type]) {
                        this.longTermMemory[type] = [];
                    }
                    this.longTermMemory[type].push(entry);
                }

                await this._persist();
                return entry.id;
            }

            async recall(query, type = null, limit = 5) {
                let candidates = [];

                if (type) {
                    candidates = this.longTermMemory[type] || [];
                } else {
                    // Search all memory types
                    Object.values(this.longTermMemory).forEach(arr => {
                        candidates = candidates.concat(arr);
                    });
                    candidates = candidates.concat(this.shortTermMemory);
                }

                // Simple relevance scoring
                const scored = candidates.map(entry => ({
                    entry,
                    score: this._calculateRelevance(query, entry)
                })).filter(item => item.score > 0);

                return scored
                    .sort((a, b) => b.score - a.score)
                    .slice(0, limit)
                    .map(item => item.entry);
            }

            _calculateRelevance(query, entry) {
                const queryLower = query.toLowerCase();
                const contentLower = JSON.stringify(entry.content).toLowerCase();
                
                // Simple keyword matching
                const queryWords = queryLower.split(/\s+/);
                let score = 0;
                
                queryWords.forEach(word => {
                    if (contentLower.includes(word)) {
                        score += 1;
                    }
                });

                // Time decay (recent memories are more relevant)
                const age = Date.now() - entry.timestamp;
                const ageFactor = Math.max(0, 1 - (age / (1000 * 60 * 60 * 24))); // Decay over 24 hours
                score *= ageFactor;

                return score;
            }

            _generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }

            async _persist() {
                const data = {
                    shortTermMemory: this.shortTermMemory,
                    longTermMemory: this.longTermMemory,
                    scriptMemory: this.scriptMemory,
                    learningMemory: this.learningMemory
                };
                localStorage.setItem('agentMemory', JSON.stringify(data));
            }
        }

        // Agentic Tool System
        class AgenticTools {
            constructor(agent) {
                this.agent = agent;
                this.tools = new Map();
                this._initializeTools();
            }

            _initializeTools() {
                // Scene Analysis Tool
                this.tools.set('sceneAnalyzer', {
                    name: 'Scene Analyzer',
                    description: 'Analyzes scenes for pacing, tension, and subtext',
                    execute: async (params, context) => {
                        const prompt = `Analyze this scene for pacing, tension arc, and subtext. Provide constructive directorial notes.\n\nScene: ${params.scene}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });

                // Dialogue Consistency Tool
                this.tools.set('dialogueChecker', {
                    name: 'Dialogue Consistency Checker',
                    description: 'Checks dialogue consistency with character profiles',
                    execute: async (params, context) => {
                        const prompt = `Check if the dialogue is consistent with character personalities. Provide specific feedback for each character.\n\nDialogue: ${params.dialogue}\n\nCharacters: ${params.characters}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });

                // Character Development Tool
                this.tools.set('characterDeveloper', {
                    name: 'Character Developer',
                    description: 'Develops and enhances character profiles',
                    execute: async (params, context) => {
                        const prompt = `Develop this character profile with depth and nuance. Consider their role in the story.\n\nCharacter: ${params.character}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });

                // Plot Continuity Tool
                this.tools.set('plotContinuity', {
                    name: 'Plot Continuity Checker',
                    description: 'Checks plot continuity and story consistency',
                    execute: async (params, context) => {
                        const prompt = `Analyze plot continuity and identify any inconsistencies or plot holes.\n\nScript: ${params.script}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });

                // Creative Suggestions Tool
                this.tools.set('creativeSuggester', {
                    name: 'Creative Suggester',
                    description: 'Provides creative suggestions and ideas',
                    execute: async (params, context) => {
                        const prompt = `Provide creative suggestions to enhance this scene/character/plot element.\n\nContext: ${params.context}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });

                // Auto-Continue Tool
                this.tools.set('autoContinue', {
                    name: 'Auto-Continue Writer',
                    description: 'Continues writing when stuck',
                    execute: async (params, context) => {
                        const prompt = `Continue this script in a natural, engaging way. Write 5-10 lines that maintain the current tone and character voices.\n\nCurrent script: ${params.currentScript}`;
                        return await this.agent._callOllama(prompt, context);
                    }
                });
            }

            async execute(toolName, params, context) {
                const tool = this.tools.get(toolName);
                if (!tool) {
                    throw new Error(`Tool '${toolName}' not found`);
                }

                await this.agent.memory.store('tool_execution', {
                    tool: toolName,
                    params,
                    timestamp: Date.now()
                });

                return await tool.execute(params, context);
            }

            getAvailableTools() {
                return Array.from(this.tools.entries()).map(([key, tool]) => ({
                    key,
                    name: tool.name,
                    description: tool.description
                }));
            }
        }

        // Main Agentic AI Agent
        class AIAgent {
            constructor() {
                this.memory = new AgentMemory();
                this.tools = new AgenticTools(this);
                this.currentTask = null;
                this.taskQueue = [];
                this.isProcessing = false;
                this.personality = 'collaborative'; // collaborative, analytical, creative
                this.ollamaUrl = localStorage.getItem('ollamaUrl') || 'http://localhost:11434/api/generate';
            }

            async initialize() {
                await this.memory.initialize();
                console.log('ü§ñ Agentic AI System initialized');
            }

            // Main agentic task execution
            async executeTask(taskDescription, context = {}) {
                if (this.isProcessing) {
                    this.taskQueue.push({ task: taskDescription, context });
                    return 'Task queued. Agent is currently processing another request.';
                }

                this.isProcessing = true;
                this.currentTask = taskDescription;

                try {
                    // Store the task
                    await this.memory.store('task', {
                        description: taskDescription,
                        context,
                        status: 'started'
                    });

                    // Create execution plan using AI
                    const plan = await this._createExecutionPlan(taskDescription, context);
                    
                    // Execute the plan
                    const result = await this._executePlan(plan, context);

                    // Store the result
                    await this.memory.store('task_result', {
                        task: taskDescription,
                        result,
                        plan,
                        status: 'completed'
                    });

                    return result;
                } catch (error) {
                    console.error('Agentic task execution failed:', error);
                    await this.memory.store('task_error', {
                        task: taskDescription,
                        error: error.message,
                        status: 'failed'
                    });
                    return `Task execution failed: ${error.message}`;
                } finally {
                    this.isProcessing = false;
                    this.currentTask = null;
                    
                    // Process next task in queue
                    if (this.taskQueue.length > 0) {
                        const nextTask = this.taskQueue.shift();
                        setTimeout(() => this.executeTask(nextTask.task, nextTask.context), 100);
                    }
                }
            }

            // Create execution plan using AI reasoning
            async _createExecutionPlan(task, context) {
                const availableTools = this.tools.getAvailableTools();
                const toolsInfo = availableTools.map(t => `${t.key}: ${t.description}`).join('\n');

                const planningPrompt = `You are an intelligent AI assistant for screenplay development. Create a step-by-step execution plan for this task: "${task}"

Available tools:
${toolsInfo}

Context: ${JSON.stringify(context, null, 2)}

Create a plan as a JSON array. Each step should have:
- step: sequential number
- action: tool name from available tools
- parameters: object with required parameters
- purpose: what this step accomplishes

Example format:
[{"step": 1, "action": "sceneAnalyzer", "parameters": {"scene": "scene text"}, "purpose": "analyze scene structure"}]`;

                const planResponse = await this._callOllama(planningPrompt, '');
                
                try {
                    // Parse the plan
                    const plan = JSON.parse(planResponse);
                    if (!Array.isArray(plan)) {
                        throw new Error('Plan must be an array');
                    }
                    return plan;
                } catch (error) {
                    // Fallback to simple plan
                    console.warn('Failed to parse AI plan, using fallback:', error);
                    return await this._createFallbackPlan(task, context);
                }
            }

            // Fallback plan creation
            async _createFallbackPlan(task, context) {
                const taskLower = task.toLowerCase();
                
                if (taskLower.includes('scene') || taskLower.includes('analyze')) {
                    return [{
                        step: 1,
                        action: 'sceneAnalyzer',
                        parameters: { scene: context.script || '' },
                        purpose: 'Analyze the scene'
                    }];
                }
                
                if (taskLower.includes('dialog') || taskLower.includes('consistency')) {
                    return [{
                        step: 1,
                        action: 'dialogueChecker',
                        parameters: { 
                            dialogue: context.script || '',
                            characters: context.characters || ''
                        },
                        purpose: 'Check dialogue consistency'
                    }];
                }
                
                if (taskLower.includes('character')) {
                    return [{
                        step: 1,
                        action: 'characterDeveloper',
                        parameters: { character: context.character || '' },
                        purpose: 'Develop character profile'
                    }];
                }
                
                if (taskLower.includes('continue') || taskLower.includes('stuck')) {
                    return [{
                        step: 1,
                        action: 'autoContinue',
                        parameters: { currentScript: context.script || '' },
                        purpose: 'Continue the script'
                    }];
                }
                
                // Default to creative suggestions
                return [{
                    step: 1,
                    action: 'creativeSuggester',
                    parameters: { context: JSON.stringify(context) },
                    purpose: 'Provide creative suggestions'
                }];
            }

            // Execute the multi-step plan
            async _executePlan(plan, context) {
                let accumulatedContext = context;
                let results = [];

                for (const step of plan) {
                    try {
                        const stepResult = await this.tools.execute(
                            step.action, 
                            step.parameters, 
                            accumulatedContext
                        );
                        
                        results.push({
                            step: step.step,
                            action: step.action,
                            purpose: step.purpose,
                            result: stepResult
                        });

                        // Accumulate context for next steps
                        accumulatedContext[`step_${step.step}_result`] = stepResult;

                    } catch (error) {
                        console.error(`Step ${step.step} failed:`, error);
                        results.push({
                            step: step.step,
                            action: step.action,
                            purpose: step.purpose,
                            error: error.message
                        });
                    }
                }

                // Synthesize final result
                return await this._synthesizeResults(results, plan, context);
            }

            // Synthesize results from multiple steps
            async _synthesizeResults(results, plan, originalContext) {
                const resultsText = results.map(r => 
                    `Step ${r.step} (${r.action}): ${r.result || r.error}`
                ).join('\n\n');

                const synthesisPrompt = `You are an AI assistant for screenplay development. Synthesize these results into a comprehensive response.

Original task: ${this.currentTask}
Original context: ${JSON.stringify(originalContext, null, 2)}

Execution results:
${resultsText}

Provide a clear, helpful response that addresses the original task. If there were errors, suggest alternatives.`;

                return await this._callOllama(synthesisPrompt, '');
            }

            // Core Ollama API call (enhanced)
            async _callOllama(prompt, context) {
                try {
                    const response = await fetch(this.ollamaUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'llama3.2',
                            prompt: `${context}\n\n${prompt}`,
                            stream: false
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();

                    if (data && data.response) {
                        return data.response;
                    } else if (data && data.text) {
                        return data.text;
                    } else if (data && typeof data === 'string') {
                        return data;
                    } else {
                        console.error('Unexpected response format:', data);
                        return 'Unerwartetes Antwortformat von Ollama';
                    }
                } catch (error) {
                    console.error('Ollama API Error:', error);

                    if (error.message.includes('CORS') || error.message.includes('Mixed Content')) {
                        return `CORS-Fehler: Die Website (HTTPS) kann nicht auf lokales Ollama (HTTP) zugreifen.\n\nL√∂sungen:\n1. Ollama mit CORS starten: OLLAMA_ORIGINS=https://sohaltweil.de ollama serve\n2. Ollama auf HTTPS-Server hosten\n3. Browser-Einstellungen anpassen (unsichere Inhalte erlauben)\n\nTechnischer Fehler: ${error.message}`;
                    }

                    return `Fehler bei der Verbindung zu Ollama: ${error.message}\n\nStellen Sie sicher, dass:\n- Ollama l√§uft (${this.ollamaUrl})\n- Das Modell 'llama3.2' verf√ºgbar ist\n- CORS f√ºr diese Domain erlaubt ist`;
                }
            }

            // Proactive analysis
            async performProactiveAnalysis() {
                const script = document.getElementById('script')?.value || '';
                if (script.length < 100) return; // Not enough content

                const task = 'Perform a quick proactive analysis of the current script to identify potential issues or opportunities for improvement';
                const context = {
                    script: script.substring(0, 1000), // Limit context size
                    type: 'proactive',
                    timestamp: Date.now()
                };

                return await this.executeTask(task, context);
            }

            // Get agent status
            getStatus() {
                return {
                    isProcessing: this.isProcessing,
                    currentTask: this.currentTask,
                    queueLength: this.taskQueue.length,
                    personality: this.personality,
                    memorySize: Object.keys(this.memory.longTermMemory).length
                };
            }
        }

        // Agentic Status Panel Management
        function setupAgenticStatusPanel() {
            // Update status every 2 seconds
            setInterval(updateAgenticStatus, 2000);

            // Proactive analysis button
            document.getElementById('agentProactiveBtn')?.addEventListener('click', async () => {
                if (aiAgent) {
                    addMessage('ü§ñ Starting proactive analysis...', true);
                    const result = await aiAgent.performProactiveAnalysis();
                    addMessage(result);
                }
            });

            // Clear memory button
            document.getElementById('agentClearMemoryBtn')?.addEventListener('click', async () => {
                if (aiAgent && confirm('Clear all agent memory? This cannot be undone.')) {
                    localStorage.removeItem('agentMemory');
                    await aiAgent.memory.initialize();
                    addMessage('ü§ñ Agent memory cleared', false);
                }
            });
        }

        function updateAgenticStatus() {
            if (!aiAgent) return;

            const status = aiAgent.getStatus();
            const statusElement = document.getElementById('agentStatus');
            const taskElement = document.getElementById('agentCurrentTask');
            const queueElement = document.getElementById('agentQueue');
            const memoryElement = document.getElementById('agentMemory');

            // Update status
            if (status.isProcessing) {
                statusElement.textContent = 'Processing';
                statusElement.className = 'status-value processing';
            } else {
                statusElement.textContent = 'Ready';
                statusElement.className = 'status-value ready';
            }

            // Update current task
            taskElement.textContent = status.currentTask || 'None';

            // Update queue
            queueElement.textContent = status.queueLength;

            // Update memory
            memoryElement.textContent = status.memorySize;
        }

        // Enhanced initialization with agentic system
        window.addEventListener('load', async () => {
            await initDB();
            await loadAllData();
            setupAutoSave();
            setupManualToggle();
            enhanceChat();
            setupUpload();
            setupChatControls();

            // Initialize the agentic system
            aiAgent = new AIAgent();
            await aiAgent.initialize();
            console.log('ü§ñ Agentic AI System ready');

            // Setup agentic status panel
            setupAgenticStatusPanel();

            // Chat-Kontext laden
            await loadChatContext();

            // RAG initialisieren (im Hintergrund, nicht blockierend)
            initializeRAG();

            // Aktuelle Ollama URL anzeigen
            const currentUrl = localStorage.getItem('ollamaUrl') || 'http://localhost:11434/api/generate';
            document.getElementById('ollamaUrlInput').placeholder = `Aktuell: ${currentUrl}`;

            // Memory Bank Status nach dem Laden √ºberpr√ºfen
            setTimeout(checkMemoryBank, 1000);

            // Start proactive analysis after a delay
            setTimeout(() => {
                if (aiAgent) {
                    aiAgent.performProactiveAnalysis();
                }
            }, 3000);
        });
    </script>
</body>
</html>
            initializeRAG();
            await loadChatContext();
